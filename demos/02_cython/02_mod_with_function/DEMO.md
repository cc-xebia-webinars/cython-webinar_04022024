# Cython: Module with Method Demo

1. First, ensure the `python-class` Conda environment is activated. While the `cython` Conda package should be installed, if it is not, then install it.

    ```bash
    python -m pip install cython
    ```

2. Make a copy of the `demo_start` folder. Name the new copied folder `demo`.

    ```bash
    cp -R demo_start demo
    ```

3. Replace the contents of the `demo/utils/utils.pyx` file with the following code. The parameters for the `add` function have **NOT** been annotated with types to indicate to Cython what type these variables should be.

    ```cython
    def add_two_numbers(a, b):
        return a + b
    ```

4. Build the Cython extension, with the `make` command.

    ```bash
    make -B utils
    ```

5. Run the following command.

    ```bash
    python -c "import utils; print(utils.add_two_numbers(1, 2))"
    ```

6. Open the `demo/utils/utils.c` file and look for this text `__pyx_pf_5utils_add_two_numbers`. There will be three results, the first is the C function prototype. Using the C function prototype, review the type definition of the `a` and `b` function parameters. Observe the type definitions of the parameters. What are they?

    ```c
    static PyObject *__pyx_pf_5utils_add_two_numbers(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_a, PyObject *__pyx_v_b); /* proto */
    ```

    Observe how the parameters are `PyObject` types. This is because Cython does not know the types of the parameters. To gain performance improvements these types should be better defined.

7. Search for the name of the function that surrounds the text you search for. There will be three occurrences. One is the prototype at the top of the file, the second is where it is called, and third is where the function is implemented. You are looking for the third one, where the function is implemented. Observe how the function `PyNumber_Add(__pyx_v_a, __pyx_v_b)` is called to add the numbers using Python's `add` operator.

    ```c
    __pyx_t_1 = PyNumber_Add(__pyx_v_a, __pyx_v_b); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4, __pyx_L1_error)
    ```

    This code use Python's `add` operator to add two `PyObject` types together. This is not leveraging any of the benefits of Cython.
    
    **So how do we update this code to benefit from Cython and the speed of the C programming language?**

8. Replace the contents of the `demo/utils/utils.pyx` file with the following code. The parameters for the `add_two_numbers` function have been annotated with types to indicate to Cython what type these variables should be.

    ```cython
    def add_two_numbers(int a, int b):
        return a + b
    ```

9. Build the Cython extension, with the `make` command.

    ```bash
    make -B utils
    ```

10. Run the following command.

    ```bash
    python -c "import utils; print(utils.add_two_numbers(1, 2))"
    ```

    The output should be as follows:

    ```text
    3
    ```

11. Open the `demo/utils/utils.c` file and look for this text `__pyx_pf_5utils_add_two_numbers`. Three results will be found, review the first one, the C function prototype. Review the parameters of the function that surrounds the text you search for. Observe the type definitions of the parameters.

    ```c
    static PyObject *__pyx_pf_5utils_add_two_numbers(CYTHON_UNUSED PyObject *__pyx_self, int __pyx_v_a, int __pyx_v_b); /* proto */
    ```

    Unlike the earlier example, the parameters are now `int` types. This is because Cython now knows the types of the parameters. This allows Cython to generate C code that is more efficient and faster.

12. Search for the name of the function that surrounds the text you search for. There will be three occurrences. One is the prototype at the top of the file, the second is where it is called, and third is where the function is implemented. You are looking for the second one, where the function is called. Review the function that surrounds where `__pyx_pw_5utils_1add_two_numbers` is called.

    ```c
    static PyObject *__pyx_pw_5utils_1add_two_numbers(PyObject *__pyx_self, 
    #if CYTHON_METH_FASTCALL
    PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
    #else
    PyObject *__pyx_args, PyObject *__pyx_kwds
    #endif
    ) {
        // ... omitted ...
    }
    ```

    This code is wrapper code that is generated by Cython to call the `__pyx_pf_5utils_add_two_numbers` function. This code is generated by Cython to handle the Python to C conversion. Before the addition of two C integers is performed, Cython converts the Python objects to C integers.

13. Review the extension wrapper code. Particularly, examine how Cython converts the PyObject arguments to integers to perform the addition.

    ```c
    __pyx_v_a = __Pyx_PyInt_As_int(values[0]);
    __pyx_v_b = __Pyx_PyInt_As_int(values[1]);
    ```

14. Review the Cython implementation of the `add_two_numbers` function. Observe how the `a` (`__pyx_v_a`) and `b` (`__pyx_v_b`) parameters are used to perform the addition with plain C code. After the addition, the result is converted back to a Python object.

    ```c
    __pyx_t_1 = __Pyx_PyInt_From_int((__pyx_v_a + __pyx_v_b));
    ```

15. Replace the code in `demos/utils/utils.pyx` with the following code:

    ```cython
    def add_two_numbers(double a, double b):
        return a + b
    ```

16. Rebuild the program with `make`, and run the following command.

    ```bash
    python -c "import utils; print(utils.add_two_numbers(1, 2))"
    ```

    The output should be as follows. Notice the output change?

    ```text
    3.0
    ```

17. Repeat the `demo/utils/utils.c` search process from above. Review how the types conversions have changed. Using the type annotations enables Cython to produce C code for the desired types.

    ```c
    __pyx_v_a = __pyx_PyFloat_AsDouble(values[0]);
    __pyx_v_b = __pyx_PyFloat_AsDouble(values[1]);
    ```

18. In addition to the Cython type annotations, Cython also supports Python type annotations. Replace the code in `demos/utils/utils.pyx` with the following code:

    ```cython
    def add_two_numbers(a: int, b: int) -> int:
        return a + b
    ```

    -- or --

    ```cython
    def add_two_numbers(a: float, b: float) -> float:
        return a + b
    ```

    Repeat the steps above and review the generated code.

19. In Cython code, Functions declared with `def` are callable from Python, and when type annotations are applied Cython performs the conversion and to/from Python, but implements the function code in C using C types. This is a powerful feature of Cython, as it allows for the use of Python type annotations to define the function signature, while still benefiting from the performance of C code.
